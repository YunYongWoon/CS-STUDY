# Chapter 2. 운영체제 구조
![image](https://user-images.githubusercontent.com/46861704/232732075-6c8b80db-d467-43e7-b5c9-3b9e88815114.png)
## 2.1. 운영체제 서비스
- 운영체제는 프로그램 실행환경을 제공하며, 프로그램과 그 프로그램의 사용자에게 특정한 서비스를 제공한다.
- 사용자 인터페이스(UI) : 여러가지로 제공
  - GUI(그래픽 사용자 인터페이스)
  - CLI(명령어 라인 인터페이스)
  - 터치 스크린 인터페이스
- 프로그램 수행
  - 시스템은 프로그램을 메모리에 적재해 실행 할 수 있어야 함
  - 정상/비정상 모두 실행을 끝낼 수 있어야 함
- 입출력 연산
  - 운영체제가 입출력 수행의 수단을 제공
- 파일 시스템 조작
  - 파일 읽고 쓰기
  - 파일 생성 삭제
  - 지정된 파일 찾기
  - 정보 열거
  - 소유권에 기반한 권한관리/파일, 디렉터리 접근 허가
  - 개인의 선택, 혹은 특정 특성과 성능 특성을 제공하기 위해 다양한 파일 시스템 제공
- 통신
  - 프로세스 끼리 정보를 교환해야 할 경우
  - 동일한 컴퓨터에서 수행되고 있는경우 혹은 네트워크에 의해 묶여있는 경우 전부 포함
  - 공유메모리, 메시지 전달 기법(패킷)
- 오류 탐지
  - 모든 가능한 오류를 항상 의식해야 함
  - CPU, 메모리 하드웨어, 입출력장치, 프로그램 등 모든 곳에서 오류 발생 가능
  - 운영체제는 각 유형의 오류들에 적당한 조처를 해야함.
- 자원 할당
  - 다수의 프로세스/작업이 동시 진행 시, 각각 알맞는 자원을 할당해야됨.
- 기록 작성
  - 어떤 프로그램이 어떤 종류의 자원을 얼마나 사용하는지 기록
- 보호와 보안
  - 보호 : 시스템 자원에 대한 모든 접근이 통제되도록 보장
  - 보안 : 네트워크 어댑터 등과 같은 외부 입출력 장치들을 부적합한 접근 시도로부터 지키고, 침입의 탑지를 위해 모든 접속을 기록하는 것.

## 2.2. 사용자와 운영체제 인터페이스
### 명령 인터프리터
- Linux, UNIX, Window등의 운영체제 대부분에서 프로세스가 시작되거나, 사용자가 처음 로그온 할 때 수행되는 특수한 프로그램으로 취급
- 쉘(shell)로도 불림
- 사용자가 지정한 명령을 가져와 그것을 수행
- 명령어의 구현방법
  - 명령 인터프리터 자체가 명령을 실행할 코드를 가지고 있는 경우
  - 시스템 프로그램에 의해 대부분의 명령을 구현하는 것.
    - ex. `rm file.txt`
      1. `rm`이라는 파일을 찾음
      2. 파일을 메모리에 적재
      3. 매개변수 `file.txt`로 수행
      4. `file.txt` 삭제

### 그래픽 기반 사용자 인터페이스
- 사용자 친화적
- 데스크톱이라 특징지어지는 마우스를 기반으로 하는 윈도 메뉴 프로그램 사용

### 터치스크린 인터페이스
- 대부분의 모바일 시스템에서 사용
- 제스처(누름, 스와이프 등)를 취하여 상호작용

### 인터페이스의 선택
- 개인의 선호에 달려있음
- 시스템 관리자, 파워 유저들은 보통 CLI 사용
  - 하고자 하는 작업에 대해 더 빨리 접근 가능
  - 반복적인 작업을 프로그래밍하여 사용 가능
- Window 사용자들은 GUI
- IOS, Android는 대부분 터치스크린 인터페이스

## 2.3. 시스템 콜
- 운영체제에 의해 사용 가능하게 된 서비스에 대한 인터페이스 제공
- 저수준 작업(하드웨어 직접 접근 등)은 어셈블리 명령을 사용하여 작성되어야 하더라도 호출은 C, CPP 언어로 작성된 함수 형태로 제공

![image](https://user-images.githubusercontent.com/46861704/232978628-0539db0c-80f2-469a-8c34-ff745989ea37.png)
### 예시
- 위 그림의 경우처럼, 한 작업에도 많은 시스템 콜이 사용될 수 있다.

### 응용 프로그래밍 인터페이스
- 사용자 대부분은 운영체제의 기능을 많이 사용하지만, 깊은 정도의 상세는 알지 못한다.
- 따라서, 대부분 API를 사용하여 프로그램을 설계함.
- API는 각 함수에 전달되어야 할 매개변수들과 프로그래머가 기대 할 수 있는 반환값을 포함하여 응용프로그래머가 사용 가능한 함수의 집합을 명시
- API를 선호하는 이유는 프로그램의 호환성, RTE 등이 있다
  - 호환성 : 프로그래머는 같은 API를 지원하는 어느 시스템에서건 컴파일되고 실행된다는 것을 기대할 수 있다.
  - RTE(실행시간 환경) : 컴파일러 또는 인터프리터를 포함하여 특정 프로그래밍 언어로 작성된 응용 프로그램을 실행하는 데 필요한 전체 소프트웨어 제품군과 라이브러리, 또는 로더와 같은 다른 소프트웨어를 함께 가리킴.
    - 운영체제가 제공하는 시스템 콜에 대한 연결고리 역할을 하는 시스템 콜 인터페이스 제공
    - API 함수의 호출을 가로채 필요한 운영체제 시스템 콜 호출.
    - 각 시스템 콜에는 번호가 할당되고, 시스템 콜 인터페이스는 이 번호에 따라 색인되는 테이블 유지
    - 시스템 콜 인터페이스는 의도하는 시스템 콜 호출 후 상태와 반환값을 돌려줌.
- 운영체제는 매개변수 전달을 위해 세가지 방법 사용
  - 매개변수를 레지스터에 전달(5개 이하)
  - 레지스터보다 매개변수가 많을 경우, 메모리 내의 블록이나 테이블에 매개변수를 저장하고 블록의 주소를 레지스터 내의 매개변수로 전달(5개 이상)
  - 프로그램에 의해 스택에 넣어지고, 운영체제에 의해 꺼내진다.

### 시스템 콜의 유형
- 프로세스 제어
  - 끝내기, 중지
  - 적재, 수행
  - 프로세스 생성, 종료
  - 프로세스 속성 획득, 설정
  - 시간 기다림
  - 이벤트를 기다림, 알림
  - 메모리 할당 및 자유화
- 파일조작
  - 파일 생성, 삭제
  - 파일 열기, 닫기
  - 읽기, 쓰기, 위치 변경
  - 파일 속성 획득 및 설정
- 장치조작
  - 장치 요구, 방출
  - 읽기, 쓰기, 위치 변경
  - 장치 속성 획득, 설정
  - 장치의 논리적 부착 또는 분리
- 정보 유지 보수
  - 시간/날짜 설정 획득
  - 시스템 데이터 설정 획득
  - 프로세스, 파일, 장치 속성 획득 설정
- 통신
  - 통신 연결 생성 제거
  - 메시지 송수신
  - 상태 정보 전달
  - 원격장치 부착 및 분리
- 보호
  - 파일 획득 허가
  - 파일 설정 허가

## 2.4. 시스템 서비스
- 프로그램 개발과 실행을 위해 더 편리한 환경을 제공
- 파일 관리
- 상태 정보
- 파일 변경
- 프로그래밍 언어 지원
- 프로그램 적재/수행
- 통신
- 백그라운드 서비스

## 2.5. 링커와 로더
![image](https://user-images.githubusercontent.com/46861704/233824912-415e37da-c69a-49b9-9556-9190b74c8e17.png)

- 소스 파일은 임의의 물리 메모리 위치에 적재되도록 설계된 오브젝트 파일로 컴파일
- **링커**는 이러한 재배치 가능 오브젝트 파일을 하나의 이진 파일로 결합
- 로더는 이진 실행 파일을 메모리로 적재
- 동적 라이브러리는 런타임에서 로드됨.

## 2.8. 운영체제 구조
### 모놀리식 구조
- 커널의 모든 기능을 단일 주소 공간에서 실행되는 단일 정적 이진 파일에 넣는 구조
- 구현 및 확장 어려움
- 성능면에서 이점
  - 시스템 콜 인터페이스에는 오버헤드가 거의 없고 통신 속도가 빠르다

### 계층적 접근
- 모놀리식 접근법의 대안으로, 느슨하게 결합된 시스템 설계 가능
- 기능이 특정 기능 및 한정된 기능을 개별적이며 작은 구성요소로 나눔.
- 한 구성요소의 변경이 해당 구성요소에만 영향을 미침
- 장점은 구현과 디버긴의 간단함

### 마이크로 커널
- 모든 중요치 않은 구성요소를 커널로부터 제거하고, 그들을 별도의 주소 공간에 존재하는 사용자 수준 프로그램으로 구현.
- 클라이언트 프로그램과 사용자 공간에서 수행되는 다양한 서비스간에 통신을 제공
- 장점은 운영체제의 확장이 쉬움
- 또한 사용자 프로세스로 수행되기 때문에 더욱 높은 보안성과 신뢰성 제공

### 모듈
- 적재 가능 커널 모듈 기법
- 커널은 핵심적인 구성요소의 집합을 가지고 있고, 부팅 또는 실행 중에 부가적인 서비스들을 모듈을 통하여 링크
- 전체적인 결과는 계층구조와 비슷하지만, 모듈에서 임의의 다른 모듈을 호출하는데서 계층 구조보다 유연
- 중심 모듈은 단지 핵심 기능만을 가지고 있고 다른 모듈을 적재하는 방법과 모듈들과 통신하는 방법을 안다는 점에서 마이크로 커널과 유사하지만, 메시지 전달을 호출할 필요가 없기 때문에 더 효율적

### 하이브리드 시스템
- 다양한 구조를 결합하여 성능, 보안 및 편리성 문제를 해결하려는 혼용 구조

## 2.9. 운영체제의 빌딩과 부팅
### 운영체제 생성
1. 운영체제 소스 코드 작성(혹은 작성된 소스코드 확보)
2. 실행될 시스템의 운영체제 구성
3. 컴파일
4. 설치
5. 컴퓨터와 새 운영체제를 부팅

### 시스템 부트
- 커널을 적재하여 컴퓨터를 시작하는 과정을 시스템 부팅이라고 함.
  1. 부트스트랩 프로그램 또는 부트로더라고 불리는 작은 코드가 커널의 위치를 찾는다
  2. 커널이 메모리에 적재, 시작
  3. 하드웨어 초기화
  4. 루트 파일 시스템이 마운트

- 일부 컴퓨터 시스템은 다단계 부팅 과정 사용
  1. BIOS라는 비휘발성 펌웨어에 있는 소형 부트로더 실행
  2. 부트 블록이라고 하는 디스크의 정해진 위치에 있는 두번째 부트 로더를 적재
  3. 부트 블록에 저장된 프로그램은 전체 운영체제를 메모리에 적재하고 실행