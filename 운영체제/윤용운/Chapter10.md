# Chapter 10. 가상 메모리
## 배경
- 가상 메모리란?
  - 실제 물리 메모리 개념과 개발자의 논리 메모리 개념을 분리
  - 작은 메모리로도 큰 가상 주소 공간을 개발자에게 제공 가능

## 요구 페이징
- 프로그램 실행 중 필요한 페이지만 메모리에 적재됨.
- valid-invalid 비트 기법 사용
	- 메모리에 올라오면 유효, 해당 페이지가 유효하지 않거나 보조저장장치에 있으면 무효
- 페이지 폴트
  - 프로세스가 메모리에 올라와 있지 않은 페이지에 접근하면 페이지 폴트 트랩 발생
  - 처리방법
		1. 프로세스에 대한 내부 테이블 검사, 해당 메모리 참조가 유효/무효인지 알아낸다
		2. 무효한 페이지면 프로세스 중단. 유효하지만 메모리에 올라와있지 않다면 보조저장장치에서 가져옴
		3. 가용공간 검색
		4. 보조저장장치에 새로 할당된 프레임으로 해당 페이지 읽도록 요청
		5. 보조저장장치 읽기가 끝나면 페이지가 메모리에 있다는 것을 알리기 위해 페이지 테이블 갱신, 프로세스가 유지하고 있는 내부 테이블 수정
		6. 트랩에 의해 중단된 명령어 재수행.

## 페이지 교체
- 가용 프레임이 없다면? 메모리에 적재하지 못함
- 대부분의 운영체제는 페이지 스와핑과 페이지 교체를 결합하여 사용.
- 기본적으로 사용되지 않고 있는 프레임을 찾아 비우고(해당 내용을 스왑 공간에 저장), 페이지 테이블을 수정하여 프레임이 비어있도록 함. 이후 페이지 폴트 서비스 루틴이 페이지 교체 진행 
### FIFO
- 메모리에 가장 늦게 들어온 페이지를 희생시킴.
- Belady의 모순
  - 프레임을 많이 할당하는데 페이지 폴트가 더 발생하는 상황
### 최적 페이지 교체
- 앞으로 가장 오랫동안 사용되지 않을 페이지 교체
- 구현이 어려움(메모리를 어떻게 참조할 것인지를 미리 알아야 함)
### LRU
- 오랜기간 사용되지 않은 페이지 교체
- 두가지의 구현방법
  - 계수기 : 각 페이지 항목마다 사용 시간 필드를 넣고 CPU에 논리적인 시계나 계수기 추가
  - 스택 : 페이지 번호의 스택을 유지. 페이지가 참조되면 스택 중간에서 스택 top으로 이동. 
### LRU 근사 페이지 교체
- LRU를 충분히 지원하는 하드웨어는 많지 않지만, 대부분 참조 비트 형태로 어느정도 지우너함
- 기본은 0, 사용되면 1로 바뀌면서 어떤 페이지가 사용되었는지의 여부를 알 수 있음
- 부가적 참조 알고리즘
  - 일정 간격마다 참조 비트를 기록
  - 타이머 인터럽트를 걸어서 참조 비트를 시프트
### 2차 기회 알고리즘
  - FIFO + 참조비트
  - 참조비트가 0이면 교체, 1이면 참조비트를 해제시키고 다음 기회를 줌
  - circular queue 사용하여 구현
### 개선된 2차 기회 알고리즘
  - 참조비트 + 변경비트 사용
  - (0, 0) 최근에 사용되지도 변경되지도 않음 - 교체하기 최적
  - (0, 1) 최근에 사용되지는 않았지만 변경은 됨 - 해당 페이지는 교체 시 디스크에 기록해야되기 때문에 적당하지 않음
  - (1, 0) 최근에 사용은 되었지만 변경되지 않음 - 곧 사용 가능성 큼
  - (1, 1) 최근에 사용/변경됨 - 곧 다시 사용될 예정. 교체시 디스크에 기록해야됨.
### Counting-Base 교체
  - LFU
    - 참조횟수가 가장 작은 페이지 교체
  - MFU
    - 참조횟수가 가장 작은 페이지가 가장 최근 참조된 것이고 앞으로 사용될 것이라 판단

## 스래싱
- 과도한 페이지 폴트로 인해 발생
- 원인
  - CPU의 이용률이 낮아지면 Multiprogramming degree가 커짐
  - 새로운 프로세스가 실행되면서 필요여부와 상관없이 페이지 교체 진행
  - 필요한 페이지가 중복되면 페이지 폴트 발생
  - 페이지 폴트가 계속 발생함에 따라 CPU 이용률이 떨어짐
  - CPU 이용률이 떨어짐에 따라 Multiprogramming degree가 점점 커짐
  - 성능저하
- 해결방법
  - 지역 교체 알고리즘(우선순위 교체 알고리즘)
    - 프로세스가 자신의 페이지만 교체 가능
    - 완벽한 해결은 불가능
      - 페이징 장치의 큐의 평균 대기열이 길어져 페이지 폴트의 평균 서비스 시간이 늘어남.
  - 지역성 모델
    - 프로세스가 실행될 때 항상 특정한 지역에서만 메모리를 집중적으로 참조
  - 작업 집합 모델
    - 지역성을 토대로 하고 있음.
    - 최근 n번만큼의 페이지 참조를 관찰
    - 페이지가 자주 참조되면 작업집합에 계속 포함되고, 아니면 탈락
    - n이 크면 multiprogramming degree 작아지고, 작으면 스래싱 유발 가능
    - 작업 집합의 전체 합이 메모리보다 커지면 프로세스 중 하나 종료 후 페이지 반환
  - 실질적인 해결책
    - 그냥 물리메모리 늘리면 해결됨