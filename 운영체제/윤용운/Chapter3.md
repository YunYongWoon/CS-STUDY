# Chapter 3. 프로세스
## 3.1. 프로세스 개념
### 프로세스란
- 비공식적으로는 실행중인 프로그램
- 현재 활동 상태는 프로그램 카운터 값과 프로세스 레지스터의 내용으로 나타냄
- 여러 섹션으로 구분
  - 텍스트 : 실행코드(고정)
  - 데이터 : 전역변수(고정)
  - 힙 : 동적 할당 메모리
  - 스택 : 함수 호출 시 임시 데이터 저장소
- 활성화 레코드
  - 함수가 호출될 때마다 함수 매개변수, 지역 변수 및 복귀 주소를 포함
- 프로그램 자체는 프로세스가 아님
- 두 프로세스들이 동일한 프로그램에 연관될 수 있지만, 별도의 실행 순서로 간주
- 프로세스 자체가 다른 개체를 위한 실행 환경이 될 수도 있음(JVM)

### 프로세스 상태
![image](https://user-images.githubusercontent.com/46861704/234454976-70a08f70-a4f2-4098-a956-48caac37b20a.png)
- 프로세스는 실행되면서 상태가 변한다.
  - new : 프로세스 생성 중
  - running : 명령어들이 실행되고 있다
  - waiting : 프로세스가 어떤 이벤트가 일어나기를 기다린다
  - ready : 프로세스가 처리기에 할당되기를 기다린다
  - terminated : 프로세스의 실행이 종료되었다.

### 프로세스 제어 블록
- 특정 프로세스와 연관된 여러 정보를 수록하며, 다음과 같은 것들을 포함한다.
  - 프로세스 상태
  - 프로그램 카운터 : 다음에 실행할 명령어의 주소
  - CPU 레지스터들 : 나중에 프로세스가 다시 스케줄 될 때 계속 올바르게 실행되도록 하기 위해서 인터럽트 발생 시 저장
  - CPU-스케줄링 정보 : 프로세스 우선순의, 스케줄 큐에 대한 포인터와 다른 스케줄 매개변수를 포함
  - 메모리 관리 정보 : 운영체제의 의해 사용되는 메모리 시스템에 따라 기준 레지스터와 한계 레지스터의 값, 운영체제가 사용하는 메모리 시스템에 따라 페이지 테이블 또는 세그먼트 테이블등과 같은 정보를 포함
  - 회계 정보 : CPU 사용 시간, 경과된 실시간, 시간 제한, 계정 번호, 잡 또는 프로세스 번호 등을 포함
  - 입출력 상태 정보 : 프로세스에 할당된 입출력 장치들과 열린 파일의 목록 등을 포함.

### 스레드
- 현대의 운영체제는 한 프로세스가 다수의 실행 스레드를 가질 수 있도록 허용
- 다중 처리기 시스템에서 이익을 얻을 수 있음
- PCB는 각 스레드에 관한 정보를 포함하도록 확장

## 3.2. 프로세스 스케줄링
- 다중 프로그래밍의 목적 : CPU 이용을 최대화
- 시분할의 목적 : 각 프로그램이 실행되는 동안 사용자가 상호 작용할 수 있도록 프로세스들 사이에서 CPU 코어를 빈번하게 교체하는 것
- 프로세스 스케줄러 : 코어에서 실행 가능한 여러 프로세스 중에서 하나의 프로세스를 선택

### 스케줄링 큐
![image](https://user-images.githubusercontent.com/46861704/234460443-c77aecbd-7d15-45da-84ee-afd565c75f12.png)
- 프로세스가 시스템에 들어가면 준비 큐에 들어가서 준비 상태가 되어 CPU코에에서 실행되기를 기다림
   - 준비 큐 헤더에는 리스트의 첫번째 PCB에 대한 포인터가 저장되고, 각 PCB는 준비 큐의 다음 PCB를 가리키는 포인터 필드가 포함됨
- 프로세스에 CPU 코어가 할당되면, 실행되어 종료되거나 인터럽트 되거나 I/O 요청의 완료같은 특정 이벤트가 발생할 때 까지 대기 큐에 삽입된다.

![image](https://user-images.githubusercontent.com/46861704/234460516-4f24b394-53df-4910-8f7c-89a57e6c22c2.png)
- 원은 큐에 서비스를 제공하는 자원
- 화살표는 시스템의 프로세스의 흐름
- 프로세스가 I/O 요청을 공표한 다음 I/O 대기 큐에 놓일 수 있다
- 새 자식 프로세스를 만든 다음 자식의 종료를 기다리는 동안 대기 큐에 놓일 수 있다
- 인터럽트 또는 타임 슬라이스가 만료되어 프로세스가 코어에서 강제로 제거되어 준비 큐로 돌아갈 수 있다.
- 종료될 때 까지 해당 주기를 반복, 종료 시점에 모든 큐에서 제거되고 PCB 및 자원 반환

### CPU 스케줄링
- CPU 스케줄러는 준비 큐에 있는 프로세스 중 선택된 하나의 프로세스에 CPU 코어를 할당함
- I/O 바운드 프로세스는 I/O 요청을 대기하기 전에 몇 밀리초 동안만 실행할 수 있음
- CPU 바운드 프로세스에는 오랜 시간동안 CPU 코어가 필요하지만 스케줄러는 프로세스에 코어를 장기간 부여할 가능성이 없다
  - 프로세스에서 CPU코어를 강제로 제거하고 실행될 때 다른 프로세스를 스케줄 하도록 설계 할 가능성이 높다
  - 따라서 일반적으로 더 자주 실행되지만 적어도 100ms마다 한번씩 실행됨
- 스와핑
  - 메모리 및 CPU에 대한 능동적 경쟁에서 프로세스를 제거하여 다중 프로그래밍의 정도를 감소시키는 것이 유리할 수 있다는 것.
  - 나중에 프로세스를 메모리에 다시 적재할 수 있으며, 중단된 위치에서 실행을 계속 할 수 있음

### 문맥 교환(Context Switch)
![image](https://user-images.githubusercontent.com/46861704/234463335-d718b242-d309-41e2-b79e-5c809c5b593f.png)
- 프로세스를 중단했다가 재개하는 작업
- 문맥은 프로세스의 PCB에 표현
  - CPU 레지스터 값, 프로세스 상태, 메모리 관리 정보 등을 포함
- CPU의 현재 상태를 저장하는 작업을 수행하고, 나중에 연산을 재개하기 위하여 상태 복구 작업을 수행
- context switch가 수행되는 동안 시스템이 아무런 일도 하지 못하니 context switch시간은 순수한 오버헤드
- 교환속도는 메모리의 속도, 반드시 복사되어야 하는 레지스터의 수, 특수 명령어의 존재에 좌우되므로 기계마다 다르다.

## 3.3. 프로세스에 대한 연산
- 대부분 시스템 내의 프로세스들은 병행 실행될 수 있으며, 반드시 동적으로 생성되고, 제거되어야 한다.

### 프로세스 생성
- 실행되는 동안 프로세스(부모 프로세스)는 여러개의 새로운 프로세스(자식 프로세스)를 생성할 수 있다. 새로운 프로세스 역시 마찬가지로 프로세스를 생성할 수 있으며, 트리를 형성하게 된다.
- UNIX, Linux, Window드으이 현대 운영체제들은 프로세스 식별자(pid)를 통해 프로세스를 구분
- 자식 프로세스는 자원이 필요한데, 이 자원을 운영체제에서 직접 얻거나 부모의 자원의 부분을 사용하도록 제한 가능

### 프로세스 종료
- 프로세스가 exit 시스템 콜을 사용하여 자신의 삭제를 운영체제에 요청하면 프로세스가 종료됨
  - 부모 프로세스에 상태값 반환 가능
  - 물리 메모리와 가상 메모리, 열린 파일, 입출력 버퍼를 포함한 프로세스의 모든 자원이 할당 해제되고 운영체제로 반납
- 혹은 시스템 콜을 통해 다른프로세스의 종료 유발(부모가 호출 가능)
  - 자식이 자신에게 할당된 자원을 초과하여 사용할 때. 자식의 상태를 검사할 방편이 주어져야 함
  - 자식에게 할당된 테스크가 필요 없을 때
  - 부모가 exit를 하는데, 운영체제가 이후 자식이 실행하는 것을 허용하지 않는 경우
- 좀비 프로세스 : 종료되었지만 부모 프로세스가 wait() 시스템 콜을 호출하지 않은 프로세스. 짧은 시간동안 머무르고 부모가 wait()을 호출하면 운영체제에 반환
- 고아 프로세스 : 부모 프로세스가 wait() 대신 종료하게되면 발생
  - UNIX는 고아 프로세스의 새로운 부모 프로세스로 init 프로세스 할당
    - init 프로세스는 주기적으로 wait()을 호출하여 고아프로세스의 종료 상태를 수집, pid와 프로세스 테이블 항목을 반환


## 3.4. 프로세스간 통신
- 프로세스가 실행중인 다른 프로세스들과 데이터를 공유하지 않으면 독립적인 프로세스
- 다른 프로세스들에 영향을 주거나 받는다면 협력적인 프로세스
  - 협력을 허용하는 환경을 제공하는 이유
    - 정보공유
    - 계산 가속화 : 특정 태스크를 빨리 실행하고자 한다면, 서브태스크로 나누어 병렬로 실행되게 함. 다중 코어에서만 가능
    - 모듈성 : 시스템 기능을 별도의 프로세스/스레드들로 나누어 모듈식 형태로 시스템 구성
- 프로세스간 통신(IPC) : 협력적 프로세스들이 데이터를 보내거나 받을 수 있게 하는 기법
![image](https://user-images.githubusercontent.com/46861704/234473104-103be66b-3152-4b84-ba01-6ebdd6066803.png)
  - 공유 메모리 : 협력 프로세스들에 의해 공유되는 메모리 영역 구축
  - 메시지 전달 : 통신이 협력 프로세스들 사이에 교환되는 메시지를 통하여 이루어짐
  - 둘 다 통상적이며, 많은 시스템이 둘다 구현

## 3.5. 공유 메모리 시스템에서의 프로세스간 통신
- 공유 메모리 영역은 공유 메모리 세그먼트를 생성하는 프로세스의 주소 공간에 위치
  - 다른 프로세스들은 해당 세그먼트를 자신의 주소 공간에 추가
  - 공유 메모리는 둘 이상의 프로세스가 제약조건(프로세스가 다른 프로세스의 메모리에 접근 금지)를 제거하는데 동의해야함
  - 프로세스들은 공유 영역에 읽고 씀으로서 정보를 교환
- 생산자-소비자 문제
  - 여러 개의 프로세스를 어떻게 동기화할 것인가에 관한 고전적인 문제
  - 해결책중 하나로 공유 메모리를 사용할 수 있음

## 3.6. 메시지 전달 시스템에서의 프로세스간 통신
- 메시지 전달 방식은 동일한 주소 공간을 공유하지 않고도 프로세스들이 통신을 하고, 동기화 할 수 있도록 허용하는 기법을 제공
- 프로세스가 통신을 원한다면, 서로 통신 연결이 설정되어야 한다.
  - 직접 또는 간접 통신
  - 동기식 또는 비동기식 통신
  - 자동 또는 명시적 버퍼링

### 명명
- 직접통신 : 각 프로세스는 통신의 수신자 또는 통신자 이름을 명시
  - 통신을 원하는 각 프로세스의 쌍들 사이에 연결이 자동 구축. 서로는 상대방의 신원만 알면 됨
  - 연결은 정확히 두 프로세스 사이만 연관
  - 통신하는 프로세스들의 각 쌍 사이에는 정확하게 하나의 연결이 존재해야 한다.
  - 대칭성 : 송신자와 수신자 프로세스 모두 상대의 이름을 제시해야 한다. 변형으로 비대칭(송신자만 수신자 이름을 지명)
  - 모듈성을 제한.
- 간접통신 : 메일박스, 또는 포트를 통해 송수신. 추상적인 프로세스들에 의해 메일박스로 넣어지고, 제거된다.
  - 고유의 id를 가진다.
  - 한 쌍의 프로세스들 사이의 연결은 이들 프로세스가 공유 메일박스를 가질 때만 구축
  - 두개 이상의 프로세스들과 연관 가능
  - 통신하고 있는 각 프로세스 사이에는 다수의 서로 다른 연결이 존재할 수 있고, 각 연결은 하나의 메일박스에 대응

### 동기화(synchronization)
- blocking vs nonblocking -> 제어권
  - blocking은 호출된 함수가 자신의 작업을 모두 끝낼때까지 제어권을 가지고 있음.
  - nonblocking은 호출된 함수가 바로 return해서 호출한 함수에게 제어권을 주어 다른일을 할수 있게 함
- 동기식 vs 비동기식 -> 시간
  - 동기식은 요청과 결과가 **동시에** 일어나는것(요청 후 결과가 와야 다음 작업이 이루어짐)
  - 비동기식은 반대로 동시에 일어나지 않음. 요청 후 결과가 올 때 까지 다른 작업 이루어짐

### 버퍼링
- 프로세스간에 교환되는 메시지는 임시 큐에 들어가 있고, 3가지 구현방식이 있다.
  - 무용량 : 큐의 길이가 0. 송신자는 수신자가 메시지를 수신할 때까지 기다려야 함
  - 유한용량 : 큐의 길이는 n이며, 큐가 가득차면 송신자는 큐 사용이 가능해질때까지 봉쇄된다.
  - 무한용량 : 큐의 길이가 무한. 메시지들이 언제든 송신될 수 있으며, 송신자는 봉쇄되지 않는다.