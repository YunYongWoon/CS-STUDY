# Chapter 9. 메인 메모리
## 배경
- 메모리 계층 구조: I/O 병목현상 해소를 위해(레지스터, 캐시, 메인메모리, 보조기억장치)
- 프로세스가 독립된 메모리 공간을 가지도록 보장함.
  - 기준 레지스터 : 가장 작은 합법적인 물리 메모리 주소의 값을 저장
  - 상한 레지스터 : 주어진 영역의 크기를 저장
  - 프로그램은 기준 레지스터 ~ 기준 레지스터 + 상한 레지스터 범위의 모든 주소 접근 가능
  - 해당 범위 넘어서 침범하면 운영체제로 트랩(소프트웨어 인터럽트) 발생
- 주소 할당
  - 언제 주소를 할당하냐에 따라 나눔
    - 컴파일 타임 할당
      - 프로세스가 메모리에 적재될 위치를 컴파일러가 알고 있음. 위치가 변경되면 다시 컴파일되어 한다.
      - 프로그램 전체가 메모리에 올라감.
    - 로드 타임 할당
      - 컴파일 시점에 메모리 위치를 모르면, 상대 주소로 생성
      - 적재 시점에 시작 주소를 반영하여 사용자 코드 상의 주소 재설정
      - 프로그램 전체가 메모리에 올라감.
    - 런타임 할당
      - 주소 할당을 런타임시까지 연기
      - MMU 필요.
      - 대부분의 OS가 사용
- MMU
  - 논리적 주소를 재배치 레지스터를 통해 물리적 주소로 변환해주는 하드웨어
  - 프로그램에 의해 생성된 주소 : 논리 주소
  - 해당 주소와 일치하는 메모리에 올라간 주소 : 물리 주소
- 동적 로딩 (Dynamic Loading)
  - 각 루틴은 실제 호출되기 전까지 메모리에 올라오지 않고 재배치 가능한 상태로 디스크에 저장
    - main 프로그램만 메모리에 적재하여 수행
    - 해당 루틴이 다른 루틴 호출 시 호출된 루틴이 메모리에 올라와있는지 체크, 없으면 메모리에 저장.
    - 장점 : 루틴이 필요한 경우에만 저장. 메모리 공간 효율적 사용.
- DLL, Shared Library
  - Linking이 런타임에서 실행됨.
  - 해당 기능이 없다면 이미지에 해당 언어의 라이브러리, 혹은 루틴의 사본을 전부 적재해야됨.
  - 라이브러리가 여러 프로세스간에 공유 가능해짐. 따라서 메인 메모리에 DLL 인스턴스가 하나만 존재해도 됨.

## 연속 메모리 할당
- 메모리 보호
  - 위에서 말한 상한 레지스터, 재배치 레지스터 등을 사용하여 프로세스가 허용되지 않은 메모리에 접근하지 않도록 메모리를 보호할 수 있음.
- 메모리 할당
  - 가변 파티션
    - 메모리를 쪼갠다음, 한 파티션에 한 프로세스만 적재
    - 프로세스가 종료되면, 메모리 사이에 hole이 생김
    - 해결방법 : 동적 메모리 할당 문제
      - first-fit : 메모리에서 사용가능한 부분을 검색, 처음으로 찾은 공간에 할당
      - best-fit : 사용 가능 공간 중 가장 작은 공간을 할당. 리스트 정렬 순서에 따라 전체 검색 해야됨.
      - worst-fit : 가장 큰 가용 공간 선택. 남은 공간은 다른 프로세스가 사용. 정렬이 안되어있으면 전체 검색해야됨
  - 단편화
    - 단편화란? 프로세스가 적제된 후 남은 작은 공간들을 합치면 충분한 공간이 되지만, 쪼개져있어서 사용 불가능한 상황.
    - first-fit, best-fit 모두 외부 단편화로 인한 문제가 있음
      - 외부 단편화?
        - 남은 메모리 크기 > Process 크기
        - 메모리가 낭비됨
      - 내부 단편화
        - 파티션 크기 > process 크기
        - 또한 메모리가 낭비됨.
    - 해결방법
      - 압축(compaction)
        - 메모리를 한군데로 몰고 모든 가용 공간을 다른 한군데로 몰아 큰 블록 생성
        - 재배치가 어셈블 또는 적재 시에 정적으로 행해지면 불가능
        - 비용이 많이 듬.
      - 페이징
        - 외부 단편화 해결 가능

## 페이징
- 프로세스의 물리 주소 공간이 연속적이지 않아도 됨.
- 외부 단편화와 압축의 필요성을 피하는 방법
- 기본 방법
![image](https://github.com/YunYongWoon/CS-STUDY/assets/46861704/cc93616b-75d5-4d80-8d51-1b4ff454f225)
  1. 물리메모리는 프레임이라 불리는 같은 크기의 블록으로 나누고, 논리 메모리는 페이지라 불리는 같은 크기 블록으로 나눔.
  2. CPU에서 나오는 모든 주소는 페이지 번호(p)와 페이지 오프셋(d)으로 나눠짐.
     1. 페이지 번호는 페이지 테이블을 엑세스할때 사용됨
     2. 페이지 테이블은 물리 메모리의 각 프레임의 시작주소를 저장하고 있고, 오프셋은 프레임 안에서의 위치.
- 외부 단편화가 발생하지 않음.(프로세스를 동일하게 쪼개서 메인메모리에 배치하기 때문에.)
- 페이지의 크기가 커지만 내부 단편화 커지고, 작아질수록 주소 매핑 주기가 커진다.
- 운영체제는 프레임 테이블이라는 자료구조를 관리
- PTBR
  - 페이지 테이블이 커서 레지스터에 저장하지 못하는 경우, 페이지 테이블을 메인메모리에 저장 후 페이지 테이블 기준 레지스터(PTBR)가 페이지 테이블을 가리키게 함.
- TLB
  - key-value로 구성된 소형 캐시.
  - 페이지 번호와 같은 것이 발견되면 해당하는 프레임 번호 제공. 없으면 페이지 테이블 검색
  - 가득차게 되면 교체 정책을 통해 제거할 항목 선택
## 스와핑
- 프로세스 혹은 프로세스의 일부분은 실행 중 임시로 백업 저장장치에 들어가고, 실행을 계속하기 위해 다시 메모리로 돌아올 수 있음.
### 기본 스와핑
- 전체 프로세스가 다 이동
- 실제 메모리보다 더 많은 프로세스를 수용할 수 있음
### 페이징에서의 스와핑
- 표준스와핑은 시간 소요가 크기 때문에 사용을 잘 하지 않음.
- 10장에서 자세히 설명