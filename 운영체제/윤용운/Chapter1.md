# Chapter 1. 서론

## 1.1. 운영체제가 할 일
- 컴퓨터 시스템
![image](https://user-images.githubusercontent.com/46861704/231934954-68376a7e-ddbb-404d-9a95-e76deb151511.png)
  - 컴퓨터 시스템은 대개 네가지 구성요소인 하드웨어, 운영제제, 응용프로그램 및 사용자로 구분.
    - 하드웨어 : CPU, 메모리 및 입출력 장치로 구성. 기본 계산용 자원 제공
    - 운영체제 : 다양한 사용자를 위해 다양한 응용 프로그램 간의 하드웨어 사용을 제어, 조종
    - 응용 프로그램 : 사용자의 계산 문제를 해결하기 위해 자원이 어떻게 사용될지 정의한 것. (ex. 워드, 컴파일러, 브라우저 등)
  - 운영체제는 그 자체로는 유용한 기능을 수행하지 못하지만, 다른 프로그램이 작업할 수 있는 환경을 제공한다.

### 사용자 관점
- 사용자 관점에서, 운영체제는 사용자가 자원들 독점하고, 사용자가 수행하는 작업을 최대화하도록 설계되어 있다.

### 시스템 관점
- 시스템 관점에서 운영체제는 자원할당자로 볼 수 있다. 자원에 대해 서로 상충할 수 있는 많은 요청이 있으므로, 이를 효율적이고 공정하게 운영하도록 한다.
- 여러가지 입출력 장치와 사용자 프로그램을 제어
  - 프로그램의 부적절한 사용 방지

### 운영체제의 정의
운영체제에 대한 적합한 정의는 없지만, 유용한 컴퓨팅 시스템을 만드는 문제를 해결할 합리적인 방법을 제공한다.

운영체제에 포함되는 요소에도 보편적인 정의는 없지만, 운영체제는 컴퓨터에서 항상 실행되는 프로그램(커널)이며, 커널의 일부일 필요는 없는 시스템 프로그램과 시스템 작동과 관련되지 않은 응용 프로그램이 존재한다.

최근에는 커널 뿐만 아니라 미들웨어(응용 프로그램 개발자에게 추가 서비스를 제공하는 소프트웨어 프레임워크)도 포함된다(iOS, Android).

## 1.2. 컴퓨터 시스템의 구성
![image](https://user-images.githubusercontent.com/46861704/231978998-ab6afa69-8c00-4bbf-8a66-4b4787b9cc41.png)
- 현대의 컴퓨터는 하나 이상의 **CPU**와 구성요소, 공유메모리 사이의 엑세스를 제공하는 공통 **버스**를 통해 연결된 여러 **장치 컨트롤러**로 구성된다.
- 장치 컨트롤러에는 둘 이상의 장치 연결이 가능하다
- 장치 컨트롤러는 일부 로컬 버퍼 저장소와 특수 목적 레지스터 집합을 유지 관리한다. 또한 제어하는 주변 장치와 로컬 버퍼 저장소간 데이터를 이동한다.
- 각 장치 컨트롤러마다 장치 드라이버가 있다. 이는 장치 컨트롤러의 작동을 알고 있으며 운영체제에 장치에 대한 일관된 인터페이스를 제공한다.
- CPU와 장치 컨트롤러는 병렬로 실행되어 메모리 사이클을 놓고 경쟁한다. 메모리 컨트롤러는 공유메모리에 질서있게 엑세스 하기 위해 메모리에 대한 액세스를 동기화한다.

### 인터럽트
#### 인터럽트란?
- 운영체제와 하드웨어의 상호 작용 방식의 핵심부분이다.
  ![image](https://user-images.githubusercontent.com/46861704/232226198-17b82fa8-85ab-418c-91a4-9fc0f77fa7e2.png)
  1. 하드웨어는 시스템 버스를 통해 CPU에 신호를 보내 인터럽트 발생
  2. CPU는 하던 일을 중단하고 즉시 고정된 위치로 실행을 옮김.
     - 고정된 위치 : 인터럽트를 위한 서비스 루틴이 위차한 시작 주소 
  3. 인터럽트 루틴 시작
  4. 인터럽트 루틴이 완료되면, CPU는 인터럽트 되었던 연산을 재개

- 인터럽트의 서비스 루틴으로 제어 전달 방법
  1. 인터럽트 정보를 조사하는 일반적인 루틴을 호출하는 방법. 이어 인터럽트 고유의 핸들러 호출
  2. 인터럽트가 매우 빈번히 발생하기 때문에, 인터럽트 루틴에 대한 포인터들의 테이블을 대신 이용. 중간 루틴을 둘 필요 없이, 테이블을 통해 간접적으로 인터럽트 루틴 호출 가능(하위 메모리에 저장됨.)

- 인터럽트된 모든 정보를 저장해야 인터럽트 처리 후 정보 복원 가능. 
  1. 인터럽트 루틴은 반드시 명시적으로 현재의 상태를 저장
  2. 복귀하기 전 상태를 복원
  3. 인터럽트 서비스 후, 저장된 복귀 주소를 프로그램 카운터에 적재
  4. 인터럽트에 의해 중단된 연산이 인터럽트가 발생하지 않았던 것처럼 다시 시작.

#### 구현
![image](https://user-images.githubusercontent.com/46861704/232226770-604d1c9c-2b75-46e7-bbb1-969ea3a67ed7.png)
- 기본 인터럽트 매커니즘 : 인터럽트 요청 라인은 하나의 명령어의 실행이 완료할때마다 CPU가 해당 선을 가짐
  1. 장치컨트롤러가 인터럽트 발생(raise)
     - 컨트롤러가 인터럽트 요청 라인에 신호를 보냄.
  2. CPU가 인터럽트 포착(catch)
     - CPU가 컨트롤러가 보낸 요청을 탐지하면, 인터럽트 번호를 읽고 인터럽트 벡터의 인덱스로 사용
  3. 인터럽트 핸들러로 디스패치(dispatch)
     - 해당 인덱스를 사용하여 인터럽트 핸들러 루틴으로 점프
  4. 핸들러는 장치를 서비스하여 인터럽트를 지운다(clear)
     - 작업 중에 변경될 상태들 저장 
     - 인터럽트 원인을 확인
     - 필요한 처리를 수행
     - 상태 복원을 수행
     - `return_from_interrupt` 명령어를 실행하여 CPU를 인터럽트 전 실행상태로 되돌림.

- 위의 기본 인터럽트 기법 : 장치컨트롤러가 서비스할 준비가 될 때와 같은 비동기 이벤트에 CPU가 대응할 수 있게 한다. 하지만 최신 운영체제에서는 더욱 정교한 인터럽트 처리가 필요하다
  - 중요한 처리 중 인터럽트 처리 연기
  - 장치의 적절한 인터럽트 핸들러로 효율적으로 디스패치할 방법 필요
  - 우선순위가 높은 인터럽트와 낮은 인터럽트를 구분하고 적절한 긴급도로 대응할 수 있도록 해야한다.
  - 최신 컴퓨터 하드웨어에서 이 세가지 기능은 CPU 및 인터럽트 컨트롤러 하드웨어에 의해 제공.

- 벡터 방식 인터럽트 기법 : 서비스가 필요한 장치를 결정하기 위해 하나의 인터럽트 핸들러가 가능한 모든 인터럽트 소스를 검색할 필요를 줄이기 위한 방법.
  - 인터럽트 체인 : 컴퓨터에는 인터럽트 벡터의 주소 개수보다 많은 장치(처리기) 가 존재하며, 이를 해결하기 위한 방법.
  - 인터럽트 벡터의 각 원소는 인터럽트 핸들러 리스트의 헤드를 가리키며, 인터럽트 발생 시 요청을 처리할 수 있는 핸들러가 발견될때까지 상응하는 리스트의 핸들러를 하나씩 호출.
  - 큰 크기의 인터럽트 테이블의 오버헤드와 하나의 인터럽트 핸들러로 디스패치 하는 비효율성의 절충안이다.

- 우선순위 레벨
  - CPU는 모든 인터럽트를 마스킹하지 않고, 우선순위가 낮은 인터럽트 처리를 연기하고, 우선순위가 높은 인터럽트가 낮은 인터럽트의 실행을 선점할 수 있다.

### 저장장치 구조
![image](https://user-images.githubusercontent.com/46861704/232266982-e24d5d90-6bed-402c-a5c5-04e0ef13bbd2.png)
- RAM(Random-Access Memory)
  - CPU는 메모리에서만 명령 적재 가능
  - 범용 컴퓨터는 메인 메모리(RAM)이라 불리는 재기록 가능한 메모리에서 가져온다.
  - 컴퓨터 전원을 켤 때 가장 먼저 실행되는 운영체제가 적재된 부트스트랩 프로그램도 메모리에 적재
  - 폰 노이만 구조 시스템에서 실행되는 명령-실행 사이클
    - 메모리로부터 명령 인출
    - 명령 레지스터에 저장
    - 명령 해독
    - 결과가 메모리에 저장
  - 메인 메모리에 영구적 저장이 불가능한 이유
    - 모든 필요한 프로그램과 데이터를 담기엔 너무 작다
    - 전원이 공급되지 않으면 내용을 잃어버리는 휘발성 저장장치이다.

- 보조기억장치
  - HDD, NVM
  - 프로그램과 데이터 모두를 위한 저장소
  - 메인메모리보다 훨씬 느림
  - 대부분의 프로그램이 메모리에 적재되기 전 여기에 저장

- 3차 저장장치
  - CD-ROM, Blu-ray등
  - 데이터 저장 후 데이터 검색시까지 해당 데이터를 유지.
  - 속도는 더 느리고, 크기는 더 큼.
### 입출력 구조
- 인터럽트 구동 I/O는 대량 데이터 이동에 사용될 때 오버헤드가 유발될 수 있으므로, 직접 메모리 엑세스(DMA)가 사용된다.
- 장치 제어기는 CPU의 개입 없이 메ㅗ리로부터 자신의 버퍼 장치로 또는 버퍼로부터 메모리 데이터 블록 전체를 전송한다.
  - 한 바이트마다 인터럽트가 발생한느게 아닌 블록 전송이 완료될 때마다 인터럽트가 발생, 장치 컨트롤러가 전송 작업 수행중에 CPU는 다른 작업을 수행할 수 있다.
- 어떤 시스템은 버스 대신 스위치 구조를 사용, 공유 버스를 사용하기 위한 사이클을 경쟁하지 않고 동시에 통신하는 것이 가능하다.

## 1.3. 컴퓨터 시스템 구조
- CPU : 명령을 실행하는 하드웨어.
- 프로세서(Procesor) : 하나 이상의 CPU를 포함하는 물리적 칩.
- 코어(core) : CPU의 기존 계산 단위.
- 다중코어(multicore) : 동일한 CPU에 여러 컴퓨팅 코어를 포함함.
- 다중처리기(multiprocessor) : 여러 프로세서를 포함함.
### 단일 처리기 시스템
- 예전에는 대부분이었지만, 현재는 거의 없는 시스템.
- 단일 처리 코어를 가진 하나의 CPU
### 다중 처리기 시스템
- 모바일 장치/ 서버 든 최신 컴퓨터에는 다중 처리기 시스템(Multiprocessor) 환경이다.
- 단일 코어 CPU가 있는 두개 이상의 프로세서가 있다.
- 프로세서는 컴퓨터 버스 및 클록, 메모리 및 주변 장치를 공유한다.
- 프로세서가 N개라고 속도 향상 비율이 N은 아니다
  - 여러 프로세서가 하나의 작업에 협력 시 올바르게 작동하게 유지하는데 일정한 양의 오버헤드가 발생하기 때문
#### SMP
![image](https://user-images.githubusercontent.com/46861704/232280169-8f91f3f0-6bef-47f7-a911-21fe14120301.png)
- 자체 CPU를 가지는 두개의 프로세서.
- 각 CPU에는 개별 혹은 로컬 캐시, 자체 레지스터 세트가 존재.
- 모든 프로세서는 시스템 버스를 통해 물리 메모리를 공유한다.
- 많은 프로세스 동시 실행 가능
- 하나는 유휴상태, 하나는 과부화가 걸리는 등 비효율적일 수 있다
  - 특정 자료구조를 사용하는 경우 이러한 비효율성 피할 수 있음
- 프로세스 및 메모리와 같은 자원을 다양한 프로세서간에 동적으로 공유 가능, 프로세서 간 작업 부하 분산을 낮출수 있다.
  
#### 다중 코어
![image](https://user-images.githubusercontent.com/46861704/232280712-d2a30b89-b308-4bbd-99ce-2c187c076b0d.png)
- 칩 내 통신이 침 간 통신보다 빠르다.
- 여러개의 단일 코어 칩보다 여러개의 코어를 가진 칩이 전력소모가 적다.
- 각 코어에 자체 레지스터 세트 레벨과 L1캐시, 코어들이 공유하는 L2캐시.
- 운영체제 설계자 및 응용 프로그램 프로그래머에게 코어를 효율적으로 사용하는 코드를 개발하도록 압박

#### 공유 시스템 연결(NUMA)
![image](https://user-images.githubusercontent.com/46861704/232280805-53a2434b-2a22-429e-91a4-06e741355a86.png)
- 다중 처리기 시스템에 CPU를 추가하면 컴퓨팅 성능이 향상되지만, 확장성이 좋지 않고, 병목이 발생해 성능이 저하됨.
- 해당 방법은 CPU에 작고 빠른 로컬 버스를 통해 엑세스 되는 자체 로컬 메모리를 제공하는 것.
- CPU가 로컬 메모리에 엑세스 할 때 빠르고, 시스템 상호 연결에 대한 경합도 없다.
- 상호 연결을 통해 원격 메모리에 엑세스 해야 할 때 지연시간이 증가하여 성능 저하가 발생할 수 있다.

#### 블레이드 서버
- 다수의 처리기 보드 및 입출력 보드, 네트워킹 보드들이 하나의 섀시 안에 장착
- 블레이드 처리기 보드는 독립적으로 부팅, 자기 자신의 운영체제를 수행
- 여러 독립적인 다중 처리기 시스템으로 구성됨

### 클러스터형 시스템
- 둘 이상의 독자적 시스템 또는 노드들을 연결하여 구성
- 높은 가용성을 제공.
  - 클러스터 내 하나 이상의 컴퓨터 시스템이 고장나도 서비스는 계속 제공
  - 성능 저하 : 남아있는 하드웨어 수준에 비례하여 서비스를 계속 제공
  - 결함허용 : 단일 구성요소에 오류가 발생하여도 계속 작동
    - 장애 감지, 진단 및 수정할 수 있는 기법 필요
- 비대칭형 클러스터링 : 다른 컴퓨터들이 응용 프로그램을 실행하는 동안 한 컴퓨터는 긴급 대기 모드 상태 유지
- 대칭형 클러스터링 :  둘 이상의 호스트들이 응용 프로그램을 실행하고 서로 감시 
- 한 클러스터가 네트워크로 연결된 다수 컴퓨터 시스템으로 구성되므로 고성능 계산 환경을 제공하도록 사용 가능
  - 병렬화 : 프로그램을 컴퓨터의 개별 코어에서 혹은 클러스터의 각 컴퓨터에서 수행되는 불니된 요소로 나누는 작업을 포함
- 병렬 클러스터 : 여러 호스트가 공유 저장장치상의 동일한 데이터에 접근할 수 있게 한다


## 1.4. 운영체제의 작동
- 운영체제는 프로그램이 실행되는 환경을 제공
  1. 컴퓨터 전원을 켜거나, 재부팅 시 초기 프로그램(부트스트랩 프로그램) 실행
  2. CPU레지스터, 장치 컨트롤러, 메모리 내용까지 모든 시스템 초기화
  3. 운영체제 커널을 메모리에 적재
  4. 시스템과 사용자에게 서비스 제공
  5. 시스템 데몬 : 커널이 실행되는 전체 시간 동안 실행
     - 리눅스 : `systemd` : 다른 많은 데몬 실행
  6. 실행할 프로세스, 서비스할 I/O 및 응답할 사용자가 없는 경우 운영체제는 조용히 무언가 발생할때까지 대기
  7. 이벤트는 거의 항상 인터럽트를 발생
  8. 하드웨어 인터럽트, 트랩(예외) 등이 이에 해당되며, 시스템 콜이라는 특수 연산을 실행

### 다중 프로그래밍과 다중 태스킹
- 다중 프로그래밍 : CPU가 항상 한 개는 실행할 수 있도록 프로그램 구성, CPU 이용률을 높힘.
  - 다중 프로그래밍 시스템에서 운영체제는 단순히 다른 프로세스로 전환하여 실행. 해당 프로세스가 대기해야 하는 경우 CPU는 다른 프로세스로 전환.
- 다중 태스킹 : CPU는 여러 프로세스를 전환하며 실행, 전환이 자주 발생하여 사용자에게 빠른 응답시간을 제공
  - 동시에 여러 프로세스를 메모리에 유지하려면 메모리 관리 방식이 필요
  - 시스템이 다음에 실행할 프로세스를 선택할 결정을 내리는 방법이 CPU 스케쥴링
  - 여러 프로세스를 병행하게 실행하려면 프로세스 스케쥴링, 디스크 저장장치 및 메모리 관리를 포함하여 운영체제의 모든 단계에서 서로 영향을 미치는 기능이 제한되어야 함.

### 이중-모드와 다중모드 운용
운영체제는 잘못된 프로그램으로 인해 다른 프로그램 또는 운영체제가 잘못 실행될 수 없도록 보장해야 한다.
- 사용자 모드와 커널 모드
![image](https://user-images.githubusercontent.com/46861704/232291107-4481f0da-d3ad-4b2c-a6ce-1fbc419f180c.png)
  - 컴퓨터 시스템이 사용자 응용을 위해 실행될 때 시스템은 사용자 모드
  - 운영체제로부터 서비스를 요청(시스템 콜) 하면, 커널 모드로 전환
  - 잘못된 사용자로부터 운영체제를, 그리고 사용자 서로를 보호하는 방법 제공
    - 악영향을 끼칠 수 있는 일부 명령을 특권 명령으로 지정함으로서 보호를 달성
    - 특권 명령은 커널 모드에서만 수행되도록 허용
    - 사용자 모드에서 수행시 불법적인 명령으로 간주해 트랩을 건다.(ex. 커널모드 전환, IO제어, 타이머 관리 및 인터럽트 관리)
    - 두가지 모드 이상으로 확장 가능
- 시스템 콜은 사용자 프로그램이 자신을 대신하여 운영체제가 수행하도록 지정되어 있는 작업을 운영체제에 요청할 수 있는 방법 제공
  - 운영체제에 의해 수행될 동작을 사용자 프로세스가 요청할 수 있게 한다.
  - 인터럽트 벡터의 특정 위치로 트랩을 거는 형태
  - 보통은 `trap`, 몇몇 시스템은 `syscall`
  - 시스템 콜 수행 시, 하드웨어에 의해 하나의 소프트웨어 인터럽트로 취급
    - 커널은 인터럽트를 발생시킨 명령을 검사하여 어떤 시스템 콜이 발생했는지를 결정
    - 전달된 인수가 사용자 프로그램이 요청하는 서비스 유형을 표시
    - 요청이 필요로 하는 추가 정보는 레지스터, 스택 또는 메모리로 전달될 수 있음
    - 커널은 인수가 정확하고 합법적인지를 검증하고 요청을 수행 후 제어를 시스템 콜 다음의 명령으로 복귀
- 하드웨어 보호 기능이 제공되면 모드 규칙을 위반하는 오류가 하드웨어에 의해 탐지
  - 일반적으로 운영체제가 처리
  - 사용자 프로그램의 불법적인 명령, 사용자 주소 공간이 아닌 메모리 접근등의 오류 발생시 하드웨어는 운영체제로 트랩 발생
  - 트랩은 인터럽트처럼 인터럽트 벡터를 통해 제어를 운영체제에 넘긴다.
  - 오류 발생시, 운영체제는 비정상적으로 프로그램을 종료
  - 적절한 오류 메시지, 메모리 덤프. 이를 통해 프로그래머가 조사하고, 수정 후 다시 실행시킬 수 있도록 통상 파일에 저장

### 타이머
사용자 프로그램이 무한 루프에 빠지거나 시스템 호출에 실패해 제어가 운영체제로 복귀하지 않는 경우가 없도록 방지
- 타이머는 지정된 시간 후 컴퓨터를 인터럽트 하도록 설정 가능
- 고정, 가변시간 가능
- 사용자에게 제어를 양도하기 전, 운영체제는 타이머가 인터럽트를 할 수 있도록 설정되어있는지 확인
- 타이머가 인터럽트 발생 시, 제어는 자동으로 운영체제로 넘어가며 이 인터럽트를 오류로 취급 혹은 프로그램에 더 많은 시간을 줄 수 있다.
  
## 1.5. 자원 관리
- 운영체제 = 자원관리자
- 자원 : CPU, 메모리공간, 파일 저장곤간, I/O장치 등

### 프로세스 관리
- 프로세스 : 실행중인 프로그램
- 프로세스가 서브프로세스를 작행해 병행하게 실행도 가능
- 프로그램 그 자체가 프로세스가 아니다. 하나의 프로그램은 디스크에 저장된 파일의 내용과 같이 수동적 개채이지만, 프로세스는 다음 수행할 명령을 지정하는 프로그램 카운터를 가진 능동적인 개체이다.
- 프로세스는 한 시스템 내의 작업 단위이다.
- 운영체제의 역할
  - 사용자 프로세스와 시스템 프로세스의 생성/제거
  - CPU에 프로세스와 스레드 스케쥴링
  - 프로세스의 일시정지/재수행
  - 프로세스 동기화 기법 제공
  - 프로세스 통신 기법 제공

### 메모리 관리
- 운영체제의 역할
  - 메모리 사용 부분, 어느 프로세스가 사용되는지 추적
  - 메모리 공간 할당/회수
  - 어떤 프로세스들을 메모리에 적재하고 제거할 것인가 결정


### 파일 시스템 관리
- 운영체제의 역할
  - 파일 생성/제거
  - 디렉터리 생성/제거
  - 파일과 디렉터리 조작을 위한 프리미티브의 제공
  - 파일을 보조저장장치로 매핑
  - 안정적인 저장 매체에 파일 백업
  
### 대용량 저장장치 관리
- 운영체제의 역할
  - 마운팅과 언마운팅
  - 사용 가능 공간 관리
  - 저장장소 할당
  - 디스크 스케줄링
  - 저장장치 분할
  - 보호

### 캐시 관리
- 캐시의 크기가 제한되어 있으므로, 캐시 관리는 중요한 설계 문제이다.
- 디스크와 메모리 간의 데이터 전송은 통상 운영체제에 의해 제어된다.

### 임출력 시스템 관리
- 운영체제의 목적중 하나는 특정 하드웨어 장치의 특성을 숨기는 것.
- 버퍼링, 캐싱, 스풀링을 포함한 메모리 관리 구성요소
- 일반적인 장치 드라이버 인터페이스
- 특정 하드웨어 장치들을 위한 드라이버


## 1.6. 보안과 보호
- 보호란?
  - 컴퓨터 시스템이 정의한 자원에 대해 프로그램, 프로세스, 또는 사용자들의 접근을 제어하는 기법
  - 시스템은 모든 사용자를 구분할 수 있어야 하며, 대부분의 운영체제가 사용자 식별자의 리스트를 유지한다.
  - UNIX 시스템에선 사용자의 집합 또한 관리한다.
  - 떄떄로 원하는 작업을 수행하기 위해 권한을 상승해야 할 때가 있고, 이 때는 유효 사용자 식별자를 이용하여 수행된다.
  
## 1.7. 가상화
- 단일 컴퓨터의 하드웨어를 여러가지 실행 환경으로 추상화하여 개별 환경이 자신만의 컴퓨터에서 실행되고 있다는 환상을 만들 수 있는 기술.
- 가상 머신의 사용자는 단일 운영체제에서 동시에 실행되는 다양한 프로세스간 전환과 동일한 방식으로 다양한 운영체제 간 전환이 가능
- 에뮬레이션 : 소스 CPU와 대상 CPU 유형이 다른 경우 소프트웨어로 컴퓨터 하드웨어를 시뮬레이션
- 가상화 : 특정 CPU를 위해 컴파일된 운영체제가 동일 CPU용의 다른 운영체제 내에서 수행
- 가상머신 관리자 : 게스트 운영체제를 수행하고 그들의 자원 이용을 관리하며 각 게스트를 서로로부터 보호.

## 1.8. 분산 시스템
- 물리적으로 떨어져있는 이기종 컴퓨터들의 집합
- 주로 네트워크를 통해 연결되어 있음
- 네트워크란?
  - 두개 이상 시스템 간의 통신 경로
  - 사용되는 프로토콜, 노드 간의 거리, 전송 매체에 따라 다르다.
  - TCP/IP가 가장 일반적
- 노드간의 거리에 의해 유형 결정
  - LAN, WAN, MAN 등의 유형이 있으며, 단거리 통신망도 존재.
- 네트워크 운영체제는 다른 컴퓨터의 다른 프로세스가 메시지를 교환할 수 있도록 하는 통신 체계와 함께 네트워크를 통한 파일 공유와 같은 기능을 제공

## 1.9. 커널 자료구조
### 트리
- CPU 스케쥴링의 일부로 red-black 트리를 사용
### 해시 함수와 맵
- 해시 함수를 사용할 경우 O(1) 효율
- 해시 충돌(서로 다른 두개의 입력값이 하나의 출력값) 발생 가능. 리스트로 동일 해시 값을 갖는 모든 값을 수록
### 비트맵
- n개의 항의 상태를 나타내는데 사용.

## 1.10. 컴퓨팅 환경
### 전통적 컴퓨팅
- 네트워크와 연결된 PC
- 원격접근은 노트북

### 모바일 컴퓨팅
### 클라이언트-서버 컴퓨팅
- 서버 시스템이 클라이언트 시스템이 생성한 요청을 만족시키는 배치
- 계산-서버 시스템
- 파일-서버 시스템

### P2P 컴퓨팅
- 클라이언트-서버가 구분되지 않음
- 모든 노드가 피어로 간주되고, 서비스 요청/제공에 따라 클라이언트 및 서버로 동작
  1. 노드가 네트워크에 참가
  2. 중앙 검색 서비스에 자신이 제공하는 서비스 등록
  3. 특정 서비스를 원하는 노드는 중앙검색 서비스를 이용, 어떤 노드가 서비스 제공하는지 검색
  4. 나머지 통신은 해당 두 노드끼리
- 혹은
  1. 클라이언트 피어는 서비스 제공 노드를 찾기 위해 서비스 요청 메시지를 브로드캐스팅
  2. 서비스를 제공하는 노드 혹은 노드들은 피어에게 응답 메시지 전송
  3. 이는 발견 프로토콜이 제공되어야됨

### 클라우드 컴퓨팅
- 계산, 저장, 응용 모두를 네트워크를 통한 서비스로 제공
- 공중 클라우드
- 사유 클라우드
- 혼합 클라우드
- SaaS : 소프트웨어 서비스
  - 인터넷을 통해 사용가능한 하나 이상의 응용 서비스
- PaaS : 플랫폼 서비스
  - 인터넷을 통해 사용하도록 응용에 맞게 준비된 서비스 스택
- IaaS : 하부구조 서비스
  - 인터넷을 통해 사용 가능한 서버나 저장장치

### 실시간 내장형 시스템
- 특정한 작업만을 수행하는 경향
- 제한된 기능만 제공
- 거의 언제나 실시간 운영체제를 수행
- 고정딘 시간 내에 처리가 반드시 이루어져야 하며, 그렇지 않으면 시스템은 실패

## 1.11. 무료 및 오픈 소스 운영체제
- 컴파일된 이진 코드가 아니느 소스코드 형식으로 제공
- 무료 운영체제
  - 소스코드 공개
  - 무료 사용, 재배포 및 수정 허용 라이센스 받음
  - 자유 소프트웨어 운동
    - 자유롭게 소프트웨어를 실행시킬 권리
    - 소스코드 분석 및 수정 권리
    - 수정없이 배포/판매할 권리
    - 코드를 수정하여 배포/판매할 권리
- 공개 소스 운영체제
  - 무료 사용, 재배포 및 수정 허용 라이센스를 무조건 제공하진 않음

## 연습문제
1. 운영체제의 세가지 주요 목적은 무엇인가?
   - 사용자가 자원들 독점하고, 사용자가 수행하는 작업을 최대화
   - 자원에 대해 서로 상충할 수 있는 많은 요청이 있으므로, 이를 효율적이고 공정하게 운영
   - 프로그램의 부적절한 사용을 방지하고, 여러 I/O 장치와 프로그램 제어
  
2. 컴퓨팅 하드웨어를 효율적으로 사용하려면 운영체제가 필요하다고 강조하였다. 운영체제가 이 원칙을 버리고 자원을 낭비하는 것이 적절한 때는 언제인가? 그러한 시스템이 실제로 낭비하는 것이 아닌 이유는 무엇인가?
   - ??
3. 실시간 환경을 위해 운영체제를 작성할 때 프로그래머가 극복해야 하는 주요 어려움은 무엇인가?
   - 정의된 시간 내에 처리가 반드시 이루어져야 한다.
4. 커널모드와 사용자모드의 구별은 기본적인 형태의 보호(보안)로써 어떤 기능을 하는가
   - 악영향을 끼칠 수 있는 특정한 명령들을 특권 명령으로 지정, 이러한 명령은 커널 모드에서만 실행될 수 있도록 하며 사용자 모드에서 실행되면 트랩(오류)를 발생시킨다.
5. 다음 중 특권 명령이어야 하는 명령어는 무엇인가
  1. 타이머 설정
  2. 클록 읽기
  3. 메모리 내용 삭제
  4. 트랩 명령 실행
  5. 인터럽트 끄기 
  6. 장치 상태 테이블 항목 수정
  7. 사용자에서 커널 모드로 전환
  8. I/O 장치 액세스
   - 1, 3, 6, 8.

10. 캐시가 유용한 두 가지 이유를 제시하라. 어떤 문제를 해결할 수 있는가? 어떤 문제를 야기하는가? 캐시의 크기를 캐싱하는 장치만큼 크게 만들 수 있다면 캐시의 용량을 늘린 후 원래 장치를 제거하지 않는 이유는 무엇인가?
    - 두 구성요소 간 엑세스 시간이나 전송 속도의 차이가 큰 경우 성능을 향상시키기 위해 사용할 수 있다.
    - 캐시 일관성 문제. 멀티프로세스 환경에서 A의 정보가 바뀌면 A의 복사본들의 정보도 즉각 반영되어야 한다.
    - 캐시의 경우 전기가 차단되면 저장되어 있는 정보가 날아갈 수 있다(휘발성).