# Chapter 10. 가상 메모리

## 가상 메모리

- 실제 물리 메모리 개념과 개발자의 논리 메모리 개념을 분리한 것
- 메모리 크기에 대한 염려 없이 쉽게 프로그램 작성
- 페이지 공유를 통해 파일이나 메모리 공유 가능

## 요구 페이징(Demand Paging)

- 프로그램 실행 중 필요할 때만 페이지 적재
- 사용/미사용 페이지를 유효/무효 비트 기법으로 사용 가능
- 지역성 때문에 매번 페이지 폴트가 너무 자주 발생하진 않음

## 페이지 교체

- 요구 페이징 과정에서 특정 프로세스가 전체 프로세스에 대해 프레임을 요구하면, 메모리가 과할당될 수 있다
- 빈 프레임이 있다면 해당 프레임을 사용하나, 빈 프레임이 없다면 페이지 교체 알고리즘을 통해 페이지를 희생시킨다

### FIFO

- 가장 오래된 페이지 교체
- 페이지가 적재된 시간 기억
- 지역성에 대한 고려 없음 (오래된 페이지가 자주 사용될 수 있음)
    - 더 많은 프레임을 할당 받아도 페이지 폴트가 늘어날 수도 있음

### LRU

- 가장 오랜 기간 사용하지 않은 페이지 교체
- 마지막 페이지 참조 시간 기록
- 연결 리스트와 맵으로 구현 가능
    - 연결 리스트 : hit 되면 가장 앞으로, miss 되면 가장 뒤 제거 후 삽입
    - 맵 : 페이지 노드의 주소 저장

### LFU

- 가장 참조 횟수가 적은 페이지 교체
- 페이지 참조 시, 참조 횟수 누적

### MFU

- 가장 적은 참조 횟수 = 가장 최근 참조 = 앞으로 사용될 페이지 = 가장 많이 사용한 페이지 교체
- 잘 쓰이지 않음

### Clock Algorithm

- 페이지를 순차적으로 가리키는 포인터를 이동시키며 교체 결정
    - 처음에 모든 페이지의 refrence bit(r)를 1로 초기화
    - 할당된 페이지 순으로 r  = 1이면 0, 0이면 교체
    - 페이지가 참조되면 r = 1로 변경
    - 교체될 때까지 처음부터 반복

### Second Chance Algorithm

- Clock Algorithm에서 modifed bit(m)을 추가
- (r, m)에 따라 아래와 같이 판단
    - (0, 0) : 최근에 사용되지도, 변경되지도 않은 경우 ⇒ 제일 교체하기 좋은 페이지
    - (0, 1) : 최근에 사용되지는 않았지만, 변경된 경우 ⇒ 디스크 저장이 필요해 교체에 힘듦
    - (1, 0) : 최근에 사용되었으나 변경되지는 않은 경우 ⇒ 곧 다시 사용될 가능성이 높음
    - (1, 1) : 최근에 사용되고, 변경도 된 경우 ⇒ 디스크 저장도 필요하고, 다시 사용될 수 있음
- 처음에는 모든 페이지의 비트를 (1, 0)으로 초기화 / 아래로 변화
    - (1, 0) ⇒ (0, 0) , (0, 1) ⇒ (0, 0) , (1, 1) ⇒ (0, 1) , (0, 0) ⇒ 교체
    - (0, 1) ⇒ (0, 0)은 변경 내용이 있으므로 디스크 저장 필요

## 스레싱

- 작업을 불러올 최소 페이지도 없어 과도하게 페이지 폴트가 발생해 성능이 저하되는 경우

### 스레싱 원인

- Multi-programming degree가 커지며 어떤 프로세스의 페이지인지 고려 없이 교체 수행
- 교체한 프레임이 해당 프로세스에서 필요한 페이지가 되면, 다시 해당 프로세스에서 페이지 폴트가 발생하고 다른 프로세스에서 프레임을 가져온다
- 스왑인과 페이지 교체가 계속 반복된다 ⇒ 페이지에 대한 큐잉이 진행되며 CPU 이용률이 낮아진다
- CPU 스케줄러는 CPU 이용률을 보고 Multi-programming degree를 더 증가시킨다
- 계속 단계가 반복되며 페이징하는데 모든 시간을 소요하고 전체적인 성능이 저하된다

### 스레싱 해결

- 지역 교체 알고리즘
    - 자신에게 할당된 프레임 세트에서만 교체를 수행
    - 다른 프로세스의 페이지를 침범하지 않음
- 메모리의 지역성 유지
    - 지역성을 포함하기에 충분한 프레임 제공
- Working-Set 알고리즘
    - Multi-programming degree 조절
    - 프로세스 별로 지역성을 위해 특정 크기로 윈도우 LRU
        - D = $\sum WS_i$일 때, D가 전체 메모리보다 커지면 프로세스 중 하나 종료 후 페이지 반환
        - D : 모든 프로세스 전체 요구량, WS : 프로세스 i의 프레임 요구치
