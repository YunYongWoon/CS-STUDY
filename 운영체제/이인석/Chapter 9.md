# Chapter 9. 메인 메모리

## 메모리

### 레지스터

- 명령어 실행은 결국 PC에 있는 명령어를 가져오고, 피연산자를 가져오고, 실행 결과를 다시 메모리에 저장하는 행위 ⇒ 각각의 프로세스가 독립된 메모리 공간을 가지도록 보장해야 한다.
- 프로세스 메모리 공간 ⇒ 기준 레지스터 + 상한 레지스터
    - 기준 레지스터 : 허용된 가장 작은 물리 메모리 주소값
    - 상한 레지스터 : 주어진 영역의 크기
- 사용자 모드에서 수행된 프로그램이 운영체제 및 다른 프로세스의 메모리 공간 침범
    - 치명적인 오류로 간주하고 트랩 발생(소프트웨어 인터럽트)

![주소 보호](https://github.com/insukL/CS-STUDY/assets/66675919/907997f1-d8f5-4077-8a93-908481242818)

### 주소 할당 (Address binding)

- 프로그램의 논리 주소를 실제 메모리 물리 주소로 매핑하는 작업
- 바인딩 시점에 따라 구분
    - Compile Time
        - 프로세스가 적재될 메모리 위치를 컴파일러가 알 수 있는 경우
            - 컴파일 시 프로세스의 메모리 위치 결정
        - 적재될 위치가 변경된다면 다시 컴파일 되어야 함
        - 논리 주소 = 물리 주소
    - Load Time
        - 메모리 적재 위치를 모르면, 대체 가능한 상대 주소로 생성
            - 로더에서 최종 결정
        - 이진 코드를 재배치 가능 코드로 만들어두고, 메인 메모리 적재 시 바인딩
        - 시작 주소가 변경되면, 코드를 적재하기만 하면 됨
        - 논리 주소 = 물리 주소
    - Execution Time
        - 프로세스가 실행 중에 다른 메모리 위치로 이동 가능
        - 하드웨어(MMU)의 도움이 필요
        - 대부분의 OS가 사용

![메모리 로드 시간](https://github.com/insukL/CS-STUDY/assets/66675919/229fc6fe-6cc5-4ac1-8815-b4529e4b76f5)

### 논리 주소 공간 vs 물리 주소 공간

- 논리 주소 : CPU가 생성하는 일반적인 주소
- 물리 주소 : 메모리가 취급하는 주소
- 프로그램 실행 중에 가상 주소를 물리 주소로 바꾸어줘야 하는데, 이 변환 작업은 메모리 관리 장치(MMU)에 의해 실행된다.
    - MMU : 논리적 주소를 재배치 레지스터를 통해 물리적 주소로 변환
    
![MMU](https://github.com/insukL/CS-STUDY/assets/66675919/5e2d9fcd-7598-4b41-929a-6843ccc54679)

### 동적 적재

- 목적 : 메모리 공간의 효율적 사용
- 모든 루틴을 교체 가능한 형태로 디스크에 저장
- 실제 호출 전까지 루틴을 적재(Loading)하지 않음
    - 메인 프로그램만 메모리에 적재하여 수행
    - 루틴 호출 시점에 바인딩 수행

### DLL & Shared Library (동적 연결 라이브러리 및 공유 라이브러리)

- 정적 링킹과 달리 실행 시점까지 링킹하도록 미룬다 (동적 링킹)
- DLL은 사용자 프로그램이 실행될 때, 사용파 프로그램에 연결되는 시스템 라이브러리
    - 프로그램이 동적 라이브러리의 루틴을 참조하면, 로더는 DLL을 찾아 필요한 경우 메모리에 적재한다
    - 하나의 파일을 메모리에 올려서 여러 프로세스 간에 공유 가능
    - 공유 가능하다는 면에서 공유 라이브러리라고도 한다

## 연속 메모리 할당

- 일반적으로 여러 사용자 프로세스가 동시에 메모리에 상주하게 됨
- 이런 연속된 메모리에 프로세스는 목적에 맞게 효율적으로 관리되어야 한다
- 프로세스 크기에 적합한 메모리 영역을 찾아야 하는 문제가 있음

### 메모리 할당 문제 해결책

- 최초 적합
    - 할당 가능한 메모리 중 가장 처음 것을 할당
    - 일반적으로 속도가 빠름
- 최적 적합
    - 할당 가능한 메모리 중 가장 작은 것을 할당
    - 활용하기에 너무 작은 파티션 자주 발생
- 최악 적합
    - 할당 가능한 메모리 중 가장 큰 것을 할당
    - 큰 파티션을 유지하기 어려움

### 단편화(Fragmentation)

- 외부 단편화
    - 남은 메모리 > 프로세스 크기지만 연속된 공간이 아니라 할당할 수 없음
    - 어떤 알고리즘을 사용해도 발생 가능성이 존재
- 내부 단편화
    - 파티션 크기 > 프로세스인 경우 할당에 메모리 낭비 발생 ⇒ 크기의 차만큼 단편화
- 압축
    - 메모리의 내용을 모아 모든 가용 공간을 하나로 통합
    - 가장 간단한 방법 : 모든 프로세스를 재배치
        - 과정에서 적재 과정이 재배치가 가능해야 함
        - 프로세스를 일시적으로 중지해야함
        - 많은 시스템 자원이 소비됨

## 페이징

- 물리 메모리는 프레임이라 불리는 같은 크기로, 논리 메모리는 페이지라 불리는 같은 크기의 블록으로 분할
    - 프로세스가 실행될 때 페이지가 메인 메모리의 프레임으로 적재
    - 프로세스를 동일하게 쪼개 메인 메모리에 배치하므로 외부 단편화 발생하지 않음
    - 할당이 항상 프레임의 정수배로 할당되므로 내부 단편화가 크게 발생
        - 프로세스 크기가 100이면 페이지 크기(2의 거듭 제곱)가 맞아떨어지지 않으므로 남는 크기만큼 내부 단편화
- CPU에 의해 생성된 논리 주소는 페이지 번호, 페이지 오프셋으로 구성
- MMU에서 다음 단계로 물리 주소로 변환
    - 페이지 번호를 추출하여 페이지 테이블의 인덱스로 사용
    - 페이지 테이블에서 프레임 번호 추출하여 페이지 번호 대체
    - 페이지 오프셋은 유지
    
![페이징 하드웨어](https://github.com/insukL/CS-STUDY/assets/66675919/08bc5e43-c64c-4b20-b6cd-5a2cac0b4fcf)
    
- 프로그래머가 인식하는 메모리와 실제 메모리 간의 차이가 있음
    - 연속된 메모리로 사용해도 운영체제에 의해 물리 주소는 나눠져서 조정
    - 커널 내부에 프레임의 모든 정보를 저장하는 테이블 존재

### PTBR

- 페이지 테이블이 큰 경우 레지스터에 직접 저장 불가능
- 페이지 테이블을 메인 메모리에 저장하고 PTBR을 테이블을 가리키게 함
    - 페이지 테이블 사용 시 PTBR만 사용하므로 Context Switching 비용 감소

### TLB

- PTBR의 경우 오프셋 1번, 프레임 번호와 오프셋으로 만든 주소로 1번 총 2번의 메모리 접근이 필요
    - 특수한 소형 하드웨어 캐시인 TLB를 활용
- TLB에 페이지 테이블을 적재해두고 페이지 번호를 가지고 테이블 병렬 탐색

## 스와핑

- 실행 중에 임시로 백업 저장장치로 내보내어졌다가 실행을 계속하면서 메모리로 복귀
- 기본 스와핑은 전체 프로세스(다중 스레드의 경우 모든 스레드 데이터 구조 포함)가 이동해야 한다
    - 전체를 이동하는 건 너무 느려서 최신 운영체제에선 사용하지 않음

### 페이징에서 스와핑

- 페이지 아웃, 페이지 인 연산을 통해서 프로세스에 속하는 페이지만 스와핑
