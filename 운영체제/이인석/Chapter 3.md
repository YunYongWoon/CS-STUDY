# Chapter 3. 프로세스

## 프로세스 개념

### 프로세스?

프로그램 카운터와 관련 자원의 집합을 가진 능동적인 존재

- 프로세스의 메모리 배치
 
    ![프로세스 메모리 배치](https://user-images.githubusercontent.com/66675919/234749366-aa97885a-e084-4e7f-977b-7ab92867abd8.png)

- 함수가 호출되면 활성화 레코드를 스택에 푸시, 함수 종료 후 스택에서 pop
    - 활성화 레코드 : 함수 매개변수, 지역 변수 및 복귀 주소 등을 포함하는 레코드
- 스택 및 힙 섹션이 서로의 방향으로 커지더라도 운영체제는 서로 겹치지 않도록 해야 한다.

### 프로세스 상태

   ![프로세스 상태](https://user-images.githubusercontent.com/66675919/234749469-201d86c4-661a-40a4-96be-7e4802b8387a.PNG)

- 프로세스의 현재 활동에 따라 각 상태 중 하나에 위치하게 된다.
- 어느 한순간에 하나의 코어에서는 하나의 프로세스만이 실행된다.

### 프로세스 제어 블록 (Process Control Block, PCB)

특정 프로세스와 연관된 여러 정보를 수록한다.

- 프로세스 상태 : 프로세스의 상태
- 프로그램 카운터(PC) : 다음에 실행할 명령어의 주소
- CPU 레지스터 : 누산기, 인덱스 레지스터, 스택 레지스터, 범용 레지스터, 상태 코드 정보
    - 프로그램 카운터와 함께 인터럽트 발생 시 저장되어야 하는 정보
- CPU 스케줄링 정보 : 프로세스 우선순위, 스케줄 큐 포인터, 매개변수 등
- 메모리 관리 정보
- 회계 정보 : CPU 사용 시간, 경과된 시간 등
- 입출력 상태 정보

프로세스 제어 블록은 약간의 회계 데이터와 함께 프로세스를 시작시키거나 다시 시작시키는 데 필요한 모든 데이터를 위한 저장소의 역할을 한다.

## 프로세스 스케줄링

- I/O 바운드 프로세스 : 계산에 소비하는 것보다 I/O에 더 많은 시간을 소비하는 프로세스
- CPU 바운드 프로세스 : 계산에 더 많은 시간을 사용하여 I/O 요청이 적은 프로세스

### 스케줄링 큐

- 프로세스가 시스템에 들어가면 준비 큐에 들어가서 준비 상태가 됨
    - 준비 큐(Ready Queue)는 PCB의 연결 리스트로 구현

    ![프로세스 큐잉](https://user-images.githubusercontent.com/66675919/234749523-be915e6c-45af-408d-933b-a3a072e8c413.PNG) 


- 프로세스가 I/O 요청한 이후 다음 I/O 대기 큐에 놓일 수 있다.
- 프로세스는 새 자식 프로세스를 만든 다음 자식의 종료를 대기하면서 대기 큐에 놓일 수 있다.
- 인터럽트 또는 타임 슬라이스가 만료되어 프로세스가 코어에서 강제로 제거되어 준비 큐로 돌아갈 수 있다.

### CPU 스케줄링

- CPU 스케줄러는 준비 큐에 있는 프로세스 중에서 하나의 프로세스에 CPU 코어를 할당한다.
- 일부 운영체제는 스와핑이라는 중간 형태의 스케줄링을 가진다.
    - 프로세스를 메모리에서 디스크로 스왑아웃하고 현재 상태를 저장, 이후 디스크에서 메모리로 스왑인하여 상태를 복원하는 방법

### 문맥 교환

- 인터럽트가 발생하면 인터럽트 처리 이후 문맥을 복구할 수 있도록 현재 실행 중인 프로세스의 현재 문맥을 저장할 필요가 있다.
- 문맥은 CPU 레지스터의 값, 프로세스 상태, 메모리 관리 정보 등을 포함하며, PCB에 표현된다.
- 문맥 교환이 진행될 동안 시스템이 아무런 유용한 일을 못 하기 때문에 **문맥 교환 시간은 순수한 오버헤드가 된다**.

    ![문맥교환](https://user-images.githubusercontent.com/66675919/234749540-aaea9279-084a-4eac-8351-57e19977775b.PNG)

## 프로세스 스케줄링

### 프로세스 생성

- 프로세스 식별자(pid)를 사용해서 프로세스를 구분
- 자식 프로세스가 자원을 얻는 법
    - 운영체제로부터 직접 얻는다.
    - 부모 프로세스가 가진 자원의 부분 집합만을 사용하도록 제한한다.
- 자식 프로세스를 새로 생성하는 법
    - 부모 프로세스의 복사본(똑같은 프로그램과 데이터를 가짐)
    - 새로운 자식 프로세스

### Linux에서 자식 프로세스

- Linux에선 pid가 1인 systemd 프로세스가 루트 부모 프로세스 역할을 한다.
- fork() 시스템 콜로 자식 프로세서스를 생성
    - 자식 프로세스는 식별자가 fork()의 복귀 코드가 됨
    - 새로운 프로세스는 복귀 코드가 0이 된다.

### 프로세스 종료

- exit 시스템 콜을 사용해서 운영체제에 자신의 삭제를 요청
- 프로세스 삭제 시 대기 중인 부모 프로세스에 상태 값 반환 가능
- 부모 프로세스는 다양한 이유로 자식 프로세스의 실행을 종료할 수 있음
    - 자식이 자신에게 할당된 자원을 초과하여 사용할 때
    - 자식에게 할당된 태스크가 더 이상 필요 없을 때
    - 부모가 exit를 하는데, 운영체제가 자식 프로세스가 부모 없이 실행을 계속하는 것을 허용하지 않을 때
- 시스템이 부모 프로세스 종료 이후 자식 프로세스 존재를 허용하지 않은 경우, 프로세스가 종료되면 모든 자식 프로세스가 종료되는데 이것을 **연쇄식 종료**라고 하며 운영체제가 시행한다.
- 부모 프로세스가 wait()을 호출하지 않으면, 자식을 좀비 프로세스라고 한다.
- 부모 프로세스가 자식 프로세스보다 먼저 종료하는 경우, 자식을 고아 프로세스라고 한다.

## 프로세스 간 통신

프로세스 협력을 허용하는 환경을 제공하는 이유

- 정보 공유
- 계산 가속화
- 모듈성

### 공유 메모리

- 프로세스 간의 공유되는 메모리 영역 생성
- 시스템 콜을 사용하지 않아 속도가 빠름
- 메모리를 파일로 매핑하여 사용
    - 구축할 때만 시스템 콜을 사용하고 모든 접근은 일반적인 메모리 접근으로 취급하여 커널의 도움이 필요 없다.
- 버퍼를 사용하는 경우 2가지 버퍼를 사용할 수 있다.
    - 유한 버퍼 : 버퍼가 비어 있으면 소비자는 반드시 대기, 버퍼가 차있으면 생산자가 대기
    - 무한 버퍼 : 생산자는 항상 새로운 항목을 생성할 수 있다.

### 메세지 전달 시스템

- 운영체제가 메시지 전달 설비를 통하여 서로 협력하는 프로세스 간의 통신 수단 제공
- 공유 메모리에 비해 구현이 쉽다.
- 충돌 회피가 필요 없으므로 적은 양의 데이터를 교환하는데 유용

직접 통신 & 간접 통신

- 직접 통신
    - 통신을 원하는 각 프로세스 쌍들 사이에 연결을 자동을 구축, 상대방의 신원만 알면 된다.
    - 정확히 두 프로세스 사이에만 연결된다.
    - 프로세스의 각 쌍 사이에는 정확히 하나의 연결이 존재한다.
- 간접 통신
    - 메일박스 또는 포트로 송신된다.
    - 프로세스가 공유 메일 박스를 가질 때만 연결이 구축된다.
    - 연결은 두 개 이상의 프로세스들과 연괄될 수 있다.
    - 각 프로세스 사이에 다수의 서로 다른 연결이 존재할 수 있고, 각 연결은 하나의 메일박스에 대응된다.

동기식& 비동기식

- 동기식 보내기 : 송신하는 프로세스는 메시지가 수신될 때까지 봉쇄된다.
- 비동기식 보내기 : 송신하는 프로세스가 메시지를 보내고 작업을 재시작한다.
- 동기식 받기 : 메시지가 이용 가능할 때까지 수신 프로세스가 봉쇄된다.
- 비동기식 받기 : 송신하는 프로세스가 유효한 메시지 또는 널(null)을 받는다.

버퍼링

교환되는 메시지는 임시 큐에 들어있게 된다. 큐를 구현하는 방식에 따라 구분한다.

- 무용량 : 큐의 길이가 0으로 송신자는 수신자가 메시지를 수신할 때까지 기다린다.
- 유한 용량 : 큐는 유한한 길이를 가진다. 큐가 만원이면 송신자는 이용 가능할 때까지 대기한다.
- 무한 용량 : 큐는 잠재적으로 무한한 길이를 가진다. 송신자는 절대 봉쇄되지 않는다.

## 프로세스 통신 사례

### 파이프

두 프로세스가 통신할 수 있게 하는 전달자

- 일반 파이프(익명 파이프)
    - 단방향(한 종단에서 쓰고, 한 종단에서 읽는다)
    - 내부 프로세스끼리 통신 가능(대개 부모 - 자식 통신)
    - 통신 종료 후 종료하면 파이프 소멸
- 지명 파이프(네임드 파이프)
    - 양방향 통신 가능
    - 구축 되면 여러 프로세스가 이용 가능
    - 통신 프로세스 종료 이후에도 계속 존재

## 클라이언트 환경 통신

### 소켓

- 각 프로세스를 프로토콜, IP 주소, 포트 번호를 접합하여 표현

### 원격 프로시저 호출 (Remote Procedure Calls, RPC)

- IPC 기반으로 구현되지만, 서로 다른 시스템 위에서 통신  시 메시지 기반 통신
- 전달되는 메시지는 구조화되어 있음
    - 원격지 포트에서 listen 중인 RPC 데몬 주소
    - 실행되어야 하는 함수의 식별자, 매개변수
- 함수 실행 이후 별도의 메시지를 통해서 사용자에게 반환
